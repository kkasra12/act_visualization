[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "AI Act Analysis",
    "section": "",
    "text": "Code\nimport os\nimport pickle\nimport re\nimport random\n\nimport matplotlib.lines as mlines\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom IPython.display import Markdown, display\nfrom matplotlib import colormaps\nfrom matplotlib.cm import ScalarMappable\nfrom matplotlib.colors import Normalize\nimport nltk\nfrom nltk import sent_tokenize, word_tokenize\nfrom nltk.corpus import stopwords\nfrom nltk.stem import WordNetLemmatizer\nfrom seaborn import objects as so\nfrom sklearn.decomposition import PCA\nfrom tqdm.notebook import tqdm\nfrom wordcloud import WordCloud\nfrom IPython.display import Javascript\n\nfrom classifier import Classifier\nfrom node import Node, node_sum_sent\nfrom scrapper import Scrapper\n\nsns.set_style(\"darkgrid\")\nnltk.download('stopwords')\nnltk.download('punkt')\nnltk.download('wordnet')\n\n\n[nltk_data] Downloading package stopwords to /home/runner/nltk_data...\n[nltk_data]   Package stopwords is already up-to-date!\n[nltk_data] Downloading package punkt to /home/runner/nltk_data...\n[nltk_data]   Package punkt is already up-to-date!\n[nltk_data] Downloading package wordnet to /home/runner/nltk_data...\n[nltk_data]   Package wordnet is already up-to-date!\n\n\nTrue"
  },
  {
    "objectID": "index.html#word-count",
    "href": "index.html#word-count",
    "title": "AI Act Analysis",
    "section": "word count",
    "text": "word count\nin this part we should consider the following points:\n\nwe should remove the punctuations\nwe should remove the stop words\nwe should remove the numbers\nwe should remove the words with length less than 3\n\n\n\nCode\n# to see the stop words\n\", \".join(stopwords.words(\"english\"))\n\n\n\"i, me, my, myself, we, our, ours, ourselves, you, you're, you've, you'll, you'd, your, yours, yourself, yourselves, he, him, his, himself, she, she's, her, hers, herself, it, it's, its, itself, they, them, their, theirs, themselves, what, which, who, whom, this, that, that'll, these, those, am, is, are, was, were, be, been, being, have, has, had, having, do, does, did, doing, a, an, the, and, but, if, or, because, as, until, while, of, at, by, for, with, about, against, between, into, through, during, before, after, above, below, to, from, up, down, in, out, on, off, over, under, again, further, then, once, here, there, when, where, why, how, all, any, both, each, few, more, most, other, some, such, no, nor, not, only, own, same, so, than, too, very, s, t, can, will, just, don, don't, should, should've, now, d, ll, m, o, re, ve, y, ain, aren, aren't, couldn, couldn't, didn, didn't, doesn, doesn't, hadn, hadn't, hasn, hasn't, haven, haven't, isn, isn't, ma, mightn, mightn't, mustn, mustn't, needn, needn't, shan, shan't, shouldn, shouldn't, wasn, wasn't, weren, weren't, won, won't, wouldn, wouldn't\"\n\n\n\n\nCode\ndef validate_word(word):\n    word = word.lower()\n    if word.isalpha() and word not in stopwords.words(\"english\"):\n        return word\n    return None\n\ngreek_to_english = [\n    \"i\",\n    \"ii\",\n    \"iii\",\n    \"iv\",\n    \"v\",\n    \"vi\",\n    \"vii\",\n    \"viii\",\n    \"ix\",\n    \"x\",\n    \"xi\",\n    \"xii\",\n    \"xiii\",\n]\n\n\n\n\nCode\nall_words = []\nlast_article = 0\nchapter_counter = []\nfor page in scrapper.content:\n    article_number = (\n        greek_to_english.index(\n            re.search(r\"Home\\s.\\sTitle(.+?)\\s\", page[0]).group(1).strip().lower()  # type: ignore\n        )\n        + 1\n    )\n    if article_number != last_article:\n        # all_words.append(f'zArticle_{article_number}')\n        print(f\"Article {article_number} has {len(all_words)} words.\")\n        chapter_counter.append(len(all_words))\n        last_article = article_number\n    for paragraph in page:\n        for word in word_tokenize(paragraph):\n            word = validate_word(word)\n            if word:\n                all_words.append(word)\n\nvalues, count = np.unique(all_words, return_counts=True)\n\n\nArticle 1 has 0 words.\nArticle 2 has 1128 words.\nArticle 3 has 1582 words.\nArticle 4 has 6154 words.\nArticle 5 has 6193 words.\nArticle 6 has 6456 words.\nArticle 7 has 6596 words.\nArticle 8 has 6600 words.\nArticle 9 has 6836 words.\nArticle 10 has 6840 words.\nArticle 11 has 7046 words.\nArticle 12 has 7054 words.\n\n\n\n\nCode\nwords_count = list(zip(*np.unique(all_words, return_counts=True)))\nwords_count.sort(key=lambda x: x[1], reverse=True)\nwords_count[:10]\n\n\n[('ai', 237),\n ('system', 229),\n ('article', 183),\n ('shall', 180),\n ('title', 161),\n ('systems', 111),\n ('iii', 106),\n ('chapter', 104),\n ('regulation', 93),\n ('home', 85)]\n\n\n\n\nCode\nlimit = 10\nfig = sns.barplot(\n    y=[w[0] for w in words_count[:limit]], x=[w[1] for w in words_count[:limit]]\n)\nfig.set(xlabel=\"Words\", ylabel=\"Frequency\", title=f\"Top {limit} Words\")\nplt.show()\n\n\n\n\n\n\n\n\n\nas we can see, there is a word \"system\" and \"systems\" in the list. we should consider them as one word. we can use stemming or lemmatization to do that. I have tried many different algorithms, but finally I find the WordNetLemmatizer the most accurate one.\n\nlemmatization\n\n\nCode\nwnl = WordNetLemmatizer()\nstemmed_words = [wnl.lemmatize(word) for word in all_words]\nvalues, count = np.unique(stemmed_words, return_counts=True)\nsorted_counts = np.argsort(count)[::-1]\nn = 5\nprint(f\"The most {n} common stemmed words are:\")\nprint(\"\\n\".join([f\"{values[i]:&gt;10s}: {count[i]: 3d} times\" for i in sorted_counts[:n]]))\n\n\nThe most 5 common stemmed words are:\n    system:  340 times\n        ai:  237 times\n   article:  187 times\n     shall:  180 times\n     title:  161 times\n\n\n\n\nCode\nstemmed_words_count_ = list(zip(*np.unique(stemmed_words, return_counts=True)))\nstemmed_words_count_.sort(key=lambda x: x[1], reverse=True)\nstemmed_words_count = pd.DataFrame(stemmed_words_count_, columns=[\"word\", \"count\"])\nstemmed_words_count\n\n\n\n\n\n\n\n\n\nword\ncount\n\n\n\n\n0\nsystem\n340\n\n\n1\nai\n237\n\n\n2\narticle\n187\n\n\n3\nshall\n180\n\n\n4\ntitle\n161\n\n\n...\n...\n...\n\n\n1163\nvulnerable\n1\n\n\n1164\nwebsite\n1\n\n\n1165\nweight\n1\n\n\n1166\nwhereas\n1\n\n\n1167\nwhose\n1\n\n\n\n\n1168 rows × 2 columns\n\n\n\n\n\nCode\nfig = sns.barplot(\n    y=stemmed_words_count.iloc[:limit, 0], x=stemmed_words_count.iloc[:limit, 1]\n)\nfig.set(xlabel=\"Words\", ylabel=\"Frequency\", title=f\"Top {limit} Words\")\nplt.show()"
  },
  {
    "objectID": "index.html#word-cloud",
    "href": "index.html#word-cloud",
    "title": "AI Act Analysis",
    "section": "Word Cloud",
    "text": "Word Cloud\n\n\nCode\nwc = WordCloud(background_color=\"white\", max_words=1000, width=800, height=400)\nwc.generate_from_frequencies(stemmed_words_count.set_index(\"word\").to_dict()[\"count\"])\nplt.figure(figsize=(12, 6))\nplt.imshow(wc, interpolation=\"bilinear\")\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nTODO1: I should try different lemmatisers and stemmers to see which one is better. right now we have words such \"titl\", \"chapt\", \"dat\" which sounds not real words.\nTODO2: create a word cloud for each page and see if there is any pattern in the words.\nTODO3: create words density for each page and see if there is any pattern in the words.\nTODO4: perform tf-idf on the words and see if there is any pattern in the words. (we can consider each page as a document)\nTODO5: use a pretrained word2vec model to plot the words in a 2D space.\nTODO6: create new dataset for text-completion and QA models.\nTODO:density of the some words in the document"
  },
  {
    "objectID": "index.html#glove-word2vec-embedding",
    "href": "index.html#glove-word2vec-embedding",
    "title": "AI Act Analysis",
    "section": "GloVe Word2Vec Embedding",
    "text": "GloVe Word2Vec Embedding\nThe Global Vectors for word representation (GloVe), introduced by Jeffrey Pennington et al Pennington, Socher, and Manning (2014)\n\n\nCode\nfile_path = \"glove.6B/glove.6B.50d.txt\"\n!head $file_path\n\n\nhead: cannot open 'glove.6B/glove.6B.50d.txt' for reading: No such file or directory\n\n\n\n\nCode\npickle_file_path = \"word_embeddings.pkl\"\nif os.path.exists(pickle_file_path):\n    print(\"Loading word embeddings from pickle file\")\n    with open(pickle_file_path, \"rb\") as f:\n        word_embeddings = pickle.load(f)\nelse:\n    print(\"Loading word embeddings from txt file\")\n    word_embeddings = {}\n    limit = -1\n    with open(file_path, \"r\") as f:\n        for i, line in enumerate(f):\n            if i == limit:\n                break\n            values = line.split()\n            word = values[0]\n            vector = np.asarray(values[1:], dtype=\"float32\")\n            word_embeddings[word] = vector\n    print(\"Saving word embeddings to pickle file\")\n    with open(\"word_embeddings.pkl\", \"wb\") as f:\n        pickle.dump(word_embeddings, f)\n\nprint(f\"{len(word_embeddings)} words found in the embeddings.\")\n\n\nLoading word embeddings from pickle file\n400000 words found in the embeddings.\n\n\n\n\nCode\ntop = stemmed_words_count.iloc[:15].copy()\ntop_embeddings_ = [word_embeddings[w] for w in top.word]\ntop_embeddings: np.ndarray = np.array(top_embeddings_)\nprint(f\"Top {len(top)} words embeddings shape: {top_embeddings.shape}\")\n\n\nTop 15 words embeddings shape: (15, 50)"
  },
  {
    "objectID": "index.html#pca",
    "href": "index.html#pca",
    "title": "AI Act Analysis",
    "section": "PCA",
    "text": "PCA\nPCA is a function that mapps a vector to another vector with less dimensions.\n\\[\n\\begin{align*}\nf:& \\mathbb{R}^n \\rightarrow \\mathbb{R}^m, m &lt; n \\\\\n& x \\rightarrow Mx\n\\end{align*}\n\\]\n\n\nCode\npca = PCA(n_components=2)\ntop_embeddings_pca = pca.fit_transform(top_embeddings)\ntop[\"x\"] = top_embeddings_pca[:, 0]\ntop[\"y\"] = top_embeddings_pca[:, 1]\ntop\n\n\n\n\n\n\n\n\n\nword\ncount\nx\ny\n\n\n\n\n0\nsystem\n340\n-1.778601\n-0.804771\n\n\n1\nai\n237\n2.659739\n-0.694570\n\n\n2\narticle\n187\n0.387305\n0.015132\n\n\n3\nshall\n180\n0.919920\n2.539926\n\n\n4\ntitle\n161\n2.925060\n-1.077561\n\n\n5\niii\n106\n3.110993\n-0.372795\n\n\n6\nchapter\n104\n1.149682\n0.218735\n\n\n7\nregulation\n93\n-1.723553\n1.114024\n\n\n8\nauthority\n86\n-1.345177\n1.170021\n\n\n9\nhome\n85\n0.334574\n-2.272493\n\n\n10\nprovider\n81\n-2.255407\n-2.361256\n\n\n11\nreferred\n73\n0.673860\n-0.180351\n\n\n12\ndata\n68\n-2.859118\n-1.898228\n\n\n13\nconformity\n63\n-0.535149\n3.028187\n\n\n14\nrequirement\n63\n-1.664126\n1.576002\n\n\n\n\n\n\n\n\n\nCode\nplt.figure(figsize=(9, 9))\nax = sns.scatterplot(data=top, x=\"x\", y=\"y\", size=\"count\", sizes=(60, 400), legend=True)\nax.set_title(\"Top 10 Words Embeddings\")\nax.set_xlabel(\"X\")\nax.set_ylabel(\"Y\", rotation=0, labelpad=10)\n\nax.vlines(0, *ax.get_xlim(), colors=\"gray\", alpha=0.6, linestyles=\"dashed\")\nax.hlines(0, *ax.get_ylim(), colors=\"gray\", alpha=0.6, linestyles=\"dashed\")\nfor i, row in top.iterrows():\n    ax.text(row.x, row.y, row.word, fontsize=12)\n\nax.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.0)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\ntop_norm = top.copy()\nmax_font_size = 50\nmin_font_size = 15\nmin_color = 0.5\nmax_color = 1\nc = top_norm[\"count\"]\ntop_norm[\"size\"] = (c - c.min()) / (c.max() - c.min()) * (\n    max_font_size - min_font_size\n) + min_font_size\n# top_norm.drop(columns=['count'], inplace=True)\ntop_norm\n\n\n\n\n\n\n\n\n\nword\ncount\nx\ny\nsize\n\n\n\n\n0\nsystem\n340\n-1.778601\n-0.804771\n50.000000\n\n\n1\nai\n237\n2.659739\n-0.694570\n36.985560\n\n\n2\narticle\n187\n0.387305\n0.015132\n30.667870\n\n\n3\nshall\n180\n0.919920\n2.539926\n29.783394\n\n\n4\ntitle\n161\n2.925060\n-1.077561\n27.382671\n\n\n5\niii\n106\n3.110993\n-0.372795\n20.433213\n\n\n6\nchapter\n104\n1.149682\n0.218735\n20.180505\n\n\n7\nregulation\n93\n-1.723553\n1.114024\n18.790614\n\n\n8\nauthority\n86\n-1.345177\n1.170021\n17.906137\n\n\n9\nhome\n85\n0.334574\n-2.272493\n17.779783\n\n\n10\nprovider\n81\n-2.255407\n-2.361256\n17.274368\n\n\n11\nreferred\n73\n0.673860\n-0.180351\n16.263538\n\n\n12\ndata\n68\n-2.859118\n-1.898228\n15.631769\n\n\n13\nconformity\n63\n-0.535149\n3.028187\n15.000000\n\n\n14\nrequirement\n63\n-1.664126\n1.576002\n15.000000\n\n\n\n\n\n\n\n\n\nCode\nfig, ax = plt.subplots(figsize=(12, 12))\n\n# plt.plot(top_norm.x, top_norm.y, markersize=1, marker=\".\", linestyle=\"\", cmap=cmap, label = top_norm.word)\n\n# sns.scatterplot(data=top_norm, x='x', y='y', hue='color', sizes=(1,2))\ncolor_norm = Normalize(vmin=top_norm[\"count\"].min(), vmax=top_norm[\"count\"].max())\ncmap = colormaps[\"viridis\"]\n\nfor i, row in top_norm.iterrows():\n    color = cmap(color_norm(row[\"count\"]))\n    ax.plot(row.x, row.y, markersize=1, marker=\".\", linestyle=\"\", color=\"white\")\n    ax.text(\n        row.x,\n        row.y,\n        row.word,\n        fontsize=row[\"size\"],\n        color=color,\n        horizontalalignment=\"center\",\n        verticalalignment=\"center\",\n        alpha=0.8,\n        fontweight=\"bold\",\n    )\n\n\nxmin, xmax, ymin, ymax = ax.axis(\"equal\")\nax.vlines(0, xmin * 2, xmax * 2, colors=\"gray\", alpha=0.6, linestyles=\"dashed\")\nax.hlines(0, ymin * 2, ymax * 2, colors=\"gray\", alpha=0.6, linestyles=\"dashed\")\nax.set_xlim(xmin, xmax)\nax.set_ylim(ymin, ymax)\nax.set_title(\"Top 10 Words Embeddings\")\nax.set_xlabel(\"X\")\nax.set_ylabel(\"Y\", rotation=0, labelpad=10)\nfig.colorbar(\n    ScalarMappable(norm=color_norm, cmap=cmap),\n    ax=ax,\n    orientation=\"vertical\",\n    label=\"frequency\",\n)\nplt.show()"
  },
  {
    "objectID": "index.html#impoertant-bigrams",
    "href": "index.html#impoertant-bigrams",
    "title": "AI Act Analysis",
    "section": "Impoertant Bigrams",
    "text": "Impoertant Bigrams\n\n\n\n\n\n\nNote\n\n\n\nlets filter some of uninformative words…\n\n\n\n\nCode\nfiltered_words = {\n    \"chapter\",\n    \"title\",\n    \"home\",\n    \"iii\"}\n\nfrequent_bigrams = find_n_grams([w for w in stemmed_words if w not in filtered_words], 2)\nfrequent_bigrams = (\n    frequent_bigrams.to_frame().reset_index().rename(columns={\"index\": \"bigram\"})\n)\nfrequent_bigrams[\"bigram\"] = frequent_bigrams[\"bigram\"].str.join(\"_\")\n\nwc = WordCloud(background_color=\"white\", max_words=1000, width=800, height=400)\nwc.generate_from_frequencies(frequent_bigrams.set_index(\"bigram\").to_dict()[\"count\"])\nplt.figure(figsize=(12, 6))\nplt.imshow(wc, interpolation=\"bilinear\")\nplt.axis(\"off\")\nplt.show()"
  },
  {
    "objectID": "index.html#count-3-seccessive-words",
    "href": "index.html#count-3-seccessive-words",
    "title": "AI Act Analysis",
    "section": "Count 3 seccessive words",
    "text": "Count 3 seccessive words\n\n\nCode\nfrequent_threegrams = find_n_grams([w for w in stemmed_words if w not in filtered_words], 3)\nfrequent_threegrams = (\n    frequent_threegrams.to_frame().reset_index().rename(columns={\"index\": \"threegram\"})\n)\nfrequent_threegrams[\"threegram\"] = frequent_threegrams[\"threegram\"].str.join(\"_\")\nfrequent_threegrams.set_index(\"threegram\").to_dict()[\"count\"]\n\nwc = WordCloud(background_color=\"white\", max_words=1000, width=800, height=400)\nwc.generate_from_frequencies(\n    frequent_threegrams.set_index(\"threegram\").to_dict()[\"count\"]\n)\nplt.figure(figsize=(12, 6))\nplt.imshow(wc, interpolation=\"bilinear\")\nplt.axis(\"off\")\nplt.show()"
  },
  {
    "objectID": "readme.html",
    "href": "readme.html",
    "title": "install dependencies",
    "section": "",
    "text": "install dependencies\nto install dependencies, run pip install -r requirements.txt\n\n\ncreate slides\nto create slides, run\njupyter-nbconvert --to slides main.ipynb \\\n --SlidesExporter.reveal_theme=serif \\\n --SlidesExporter.reveal_scroll=True \\\n --SlidesExporter.reveal_transition=concave \\\n --SlidesExporter.exclude_input=True \\\n --SlidesExporter.reveal_number=\"v.h\"\nthere should be a file named main.slides.html. open it in a browser to view the slides.\n\n\nrerun the classification\nif you want to rerun the classification: create a Python file named config.py and define API_KEY.\necho \"API_KEY = &lt;YOUR_API_KEY&gt;\" &gt; config.py\n\ndelete the classifier.pkl file or change its name. Also, you can change the file name in the code (you can find it almost end of main.ipynb).\nrun main.ipynb again.\n\n\n\nview the slides\nto see the rendered slides click here.\n\n\nTest\nto run the tests, run\npython -m pytest"
  }
]